!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
B	hello.cc	/^	B() { cout << derp << endl; }$/;"	f	struct:B	access:public	signature:()
B	hello.cc	/^struct B {$/;"	s	file:
B::B	hello.cc	/^	B() { cout << derp << endl; }$/;"	f	struct:B	access:public	signature:()
B::derp	hello.cc	/^	const char *derp = "weee";$/;"	m	struct:B	file:	access:public
B::next	hello.cc	/^	B* next;$/;"	m	struct:B	file:	access:public
B::noez	hello.cc	/^	char const *noez = derp;$/;"	m	struct:B	file:	access:public
B::~B	hello.cc	/^	~B() { cout << derp << endl << noez << endl; }$/;"	f	struct:B	access:public	signature:()
L	lib_crypt.php	/^			$L = $retarray[0];$/;"	v
L	lib_crypt.php	/^		$L = null;$/;"	v
R	lib_crypt.php	/^			$R = $retarray[1];$/;"	v
R	lib_crypt.php	/^		$R = null;$/;"	v
X	hello.cc	/^	X() : foobar(2), derp(2) {$/;"	f	class:X	access:public	signature:()
X	hello.cc	/^class X {$/;"	c	file:
X::X	hello.cc	/^	X() : foobar(2), derp(2) {$/;"	f	class:X	access:public	signature:()
X::derp	hello.cc	/^	int derp;$/;"	m	class:X	file:	access:public
X::foobar	hello.cc	/^	int foobar;$/;"	m	class:X	file:	access:private
X::operator +	hello.cc	/^	int operator+(const X &a);$/;"	p	class:X	file:	access:public	signature:(const X &a)
X::operator +	hello.cc	/^int X::operator+(const X &a) {$/;"	f	class:X	signature:(const X &a)
X::operator =	hello.cc	/^		X &operator=(const T &a);$/;"	p	class:X	file:	access:public	signature:(const T &a)
X::operator =	hello.cc	/^	X &X::operator=(const T &a) {$/;"	f	class:X	signature:(const T &a)
X::~X	hello.cc	/^	~X() {$/;"	f	class:X	access:public	signature:()
_GNU_SOURCE	hello.c	1;"	d	file:
_encryptBlock	lib_crypt.php	/^	function _encryptBlock($L, $R) {$/;"	f
_formatKey	lib_crypt.php	/^	function _formatKey($key) {$/;"	f
_generate_iv	lib_crypt.php	/^	function _generate_iv() {$/;"	f
_hash	lib_crypt.php	/^	function _hash($string) {$/;"	f
_hex2chr	lib_crypt.php	/^	function _hex2chr($num) {$/;"	f
_start	asm.s	/^_start:$/;"	l
_start	nasmhello.s	/^_start:$/;"	l
_start	sysenter.s	/^_start:$/;"	l
_start	test.s	/^_start:                                                 # Function$/;"	l
block	lib_crypt.php	/^				$block = $pad_output_string;$/;"	v
block	lib_crypt.php	/^			$block = substr($data, $i, 8);$/;"	v
blowfish_encryption	lib_crypt.php	/^	function blowfish_encryption($key) {$/;"	f
blowfish_encryption	lib_crypt.php	/^class blowfish_encryption {$/;"	c
c	lib_crypt.php	/^		$c = 0;$/;"	v
clearArrays	lib_crypt.php	/^	function clearArrays() {$/;"	f
cmp	qsort.c	/^int cmp (const void *a, const void *b)$/;"	f
crypt	lib_crypt.php	/^\/\/ $crypt = new blowfish_encryption('the secret');$/;"	v
crypt	lib_crypt.php	/^\/\/ $crypt = new hash_encryption('the secret ...');$/;"	v
data	lib_crypt.php	/^		$data = base64_decode($encdata); \/\/ need to be symetrical$/;"	v
data	lib_crypt.php	/^		$data = trim($data); \/\/ need to be symetrical$/;"	v
dec_text	lib_crypt.php	/^\/\/ $dec_text = $crypt->decrypt($enc_text);$/;"	v
decrypt	lib_crypt.php	/^		$decrypt = '';$/;"	v
decrypt	lib_crypt.php	/^		$decrypt = trim($decrypt); \/\/ need to be symetrical$/;"	v
decrypt	lib_crypt.php	/^	function decrypt($encdata) {$/;"	f
decrypt	lib_crypt.php	/^	function decrypt($string) {$/;"	f
decryptBlock	lib_crypt.php	/^	function decryptBlock($block, $key=null) {$/;"	f
decrypted	lib_crypt.php	/^		$decrypted = pack("NN", $R ^ $this->p[0], $L);$/;"	v
derp	hello.cc	/^	const char *derp = "weee";$/;"	m	struct:B	file:	access:public
derp	hello.cc	/^	int derp;$/;"	m	class:X	file:	access:public
enc_text	lib_crypt.php	/^\/\/ $enc_text = $crypt->encrypt('text to be encrypted');$/;"	v
enc_zero	lib_crypt.php	/^			$enc_zero = $this->_encryptBlock($enc_zero['L'], $enc_zero['R']);$/;"	v
enc_zero	lib_crypt.php	/^		$enc_zero = array('L'=>0, 'R'=>0);$/;"	v
encrypt	lib_crypt.php	/^		$encrypt = '';$/;"	v
encrypt	lib_crypt.php	/^		$encrypt = base64_encode($encrypt); \/\/ need to be symetrical$/;"	v
encrypt	lib_crypt.php	/^	function encrypt($data) {$/;"	f
encrypt	lib_crypt.php	/^	function encrypt($string) {$/;"	f
encryptBlock	lib_crypt.php	/^	function encryptBlock($block, $key=null) {$/;"	f
execution	lib_crypt.php	/^	\/\/ clean the arrays after class execution$/;"	c
execution	lib_crypt.php	/^	\/\/ init the arrays before class execution$/;"	c
expon	hello.c	/^double expon(double n, double e)$/;"	f
expon	hello.cc	/^	T expon(T n, T e) {$/;"	f	signature:(T n, T e)
expon	hello.cc	/^	T expon(T, T);$/;"	p	file:	signature:(T, T)
foo	asm.s	/^	foo:$/;"	l
foo	test.s	/^foo:                                                    # byte$/;"	l
foobar	hello.cc	/^	int foobar;$/;"	m	class:X	file:	access:private
getBlockSize	lib_crypt.php	/^	function getBlockSize() {$/;"	f
get_bit	hello.cc	/^	int get_bit(T x) {$/;"	f	signature:(T x)
get_bit	hello.cc	/^	int get_bit(T);$/;"	p	file:	signature:(T)
hash_encryption	lib_crypt.php	/^	 \/\/ @see function	hash_encryption$/;"	f
hash_encryption	lib_crypt.php	/^	function hash_encryption($key) {$/;"	f
hash_encryption	lib_crypt.php	/^class hash_encryption {$/;"	c
hash_key	lib_crypt.php	/^		$this->hash_key = $this->_hash($key);$/;"	v
hash_key	lib_crypt.php	/^	var $hash_key;		\/\/ @var	string :: Hashed value of the user provided encryption key$/;"	v
hash_length	lib_crypt.php	/^			if(($c != 0) and ($c % $this->hash_length == 0)) {$/;"	v
hash_length	lib_crypt.php	/^		$this->hash_length = strlen($this->hash_key);$/;"	v
hash_length	lib_crypt.php	/^	var $hash_length;		\/\/ @var	int :: String length of hashed values using the current algorithm$/;"	v
hashes	lib_crypt.php	/^	 \/\/ This class hashes any given string using the best available hash algorithm.$/;"	c
i_max	lib_crypt.php	/^		$i_max = count($this->p);$/;"	v
i_max	lib_crypt.php	/^		$i_max = count($this->s1);$/;"	v
i_max	lib_crypt.php	/^		$i_max = count($this->s2);$/;"	v
i_max	lib_crypt.php	/^		$i_max = count($this->s3);$/;"	v
i_max	lib_crypt.php	/^		$i_max = count($this->s4);$/;"	v
ilog2	hello.c	/^uint64_t ilog2(uint64_t x)$/;"	f
implements	lib_crypt.php	/^	\/\/ The Cipher BlowFish class implements the Blowfish encryption algorithm.$/;"	c
in	lib_crypt.php	/^	\/\/ requires sha1 function in PHP$/;"	f
initArrays	lib_crypt.php	/^	function initArrays() {$/;"	f
init_arr_p	lib_crypt.php	/^	var $init_arr_p = array($/;"	v
init_arr_s1	lib_crypt.php	/^	var $init_arr_s1 = array($/;"	v
init_arr_s2	lib_crypt.php	/^	var $init_arr_s2 = array($/;"	v
init_arr_s3	lib_crypt.php	/^	var $init_arr_s3 = array($/;"	v
init_arr_s4	lib_crypt.php	/^	var $init_arr_s4 = array($/;"	v
iv	lib_crypt.php	/^		$iv  = $this->salt;$/;"	v
iv	lib_crypt.php	/^		$iv = $out = '';$/;"	v
iv	lib_crypt.php	/^		$iv = $this->_generate_iv();$/;"	v
key	lib_crypt.php	/^				$key = $this->_hash($key . substr($string,$c - $this->hash_length,$this->hash_length));$/;"	v
key	lib_crypt.php	/^				$key = $this->_hash($key.substr($out,$c - $this->hash_length,$this->hash_length));$/;"	v
key	lib_crypt.php	/^		$key = $iv;$/;"	v
key	lib_crypt.php	/^		$key = $this->_formatKey($key);$/;"	v
key	lib_crypt.php	/^	function decryptBlock($block, $key=null) {$/;"	v
key	lib_crypt.php	/^	function encryptBlock($block, $key=null) {$/;"	v
key_length	lib_crypt.php	/^		$key_length = count($key);$/;"	v
key_pos	lib_crypt.php	/^					$key_pos = 0;$/;"	v
key_pos	lib_crypt.php	/^		$key_pos = $key_xor = 0;$/;"	v
key_xor	lib_crypt.php	/^				$key_xor = ($key_xor << 8) | (($key[$key_pos]) & 0x0ff);$/;"	v
len	asm.s	/^	len = . - foo$/;"	d
len	asm.s	/^	len = . - msg                 # length of our dear string$/;"	d
len	nasmhello.s	/^	len     equ     $ - msg                  ; length of the string.$/;"	d
len	sysenter.s	/^    len = . - msg$/;"	d
len2	asm.s	/^	len2 = . - foo$/;"	d
len3	asm.s	/^	len3 = . - msg$/;"	d
main	ftm.c	/^main(int argc, char *argv[]) {$/;"	f
main	hello.c	/^int main(int argc, char **argv) {$/;"	f
main	hello.cc	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	qsort.c	/^int main(int argc, char **argv) {$/;"	f
msg	asm.s	/^msg:$/;"	l
msg	nasmhello.s	/^	msg     db      "Hello, world!",0xa      ; the string to print.$/;"	d
msg	sysenter.s	/^msg:$/;"	l
msg	test.s	/^msg:                                                    # byte$/;"	l
next	hello.cc	/^	B* next;$/;"	m	struct:B	file:	access:public
noez	hello.cc	/^	char const *noez = derp;$/;"	m	struct:B	file:	access:public
operator +	hello.cc	/^	int operator+(const X &a);$/;"	p	class:X	file:	access:public	signature:(const X &a)
operator +	hello.cc	/^int X::operator+(const X &a) {$/;"	f	class:X	signature:(const X &a)
operator =	hello.cc	/^		X &operator=(const T &a);$/;"	p	class:X	file:	access:public	signature:(const T &a)
operator =	hello.cc	/^	X &X::operator=(const T &a) {$/;"	f	class:X	signature:(const T &a)
out	lib_crypt.php	/^		$out = '';$/;"	v
out	lib_crypt.php	/^		$out = base64_encode($out);$/;"	v
out	lib_crypt.php	/^		$out ='';$/;"	v
p	lib_crypt.php	/^		$this->p 	= $this->init_arr_p;$/;"	v
p	lib_crypt.php	/^		$this->p 	= array();$/;"	v
p	lib_crypt.php	/^	var $p = array();$/;"	v
pad_calc_length	lib_crypt.php	/^				$pad_calc_length = $pad_length - strlen($pad_input_string);$/;"	v
pad_input_string	lib_crypt.php	/^				$pad_input_string = $block; \/\/ here will be passed the input string$/;"	v
pad_length	lib_crypt.php	/^				$pad_length = 8;$/;"	v
pad_output_string	lib_crypt.php	/^					$pad_output_string = $pad_input_string.str_repeat($pad_string, $pad_calc_length);$/;"	v
pad_output_string	lib_crypt.php	/^					$pad_output_string = $pad_input_string;$/;"	v
pad_output_string	lib_crypt.php	/^				$pad_output_string = ''; \/\/ cleared (init) -> this will output the final result$/;"	v
pad_string	lib_crypt.php	/^				$pad_string = "\\0";$/;"	v
parts	lib_crypt.php	/^		$parts = $this->_encryptBlock($L, $R);$/;"	v
result	lib_crypt.php	/^		$result = sha1($string);$/;"	v
retarray	lib_crypt.php	/^		$retarray = array_values(unpack('N*', $block));$/;"	v
s1	lib_crypt.php	/^		$this->s1 	= $this->init_arr_s1;$/;"	v
s1	lib_crypt.php	/^		$this->s1 	= array();$/;"	v
s1	lib_crypt.php	/^	var $s1 = array();$/;"	v
s2	lib_crypt.php	/^		$this->s2 	= $this->init_arr_s2;$/;"	v
s2	lib_crypt.php	/^		$this->s2 	= array();$/;"	v
s2	lib_crypt.php	/^	var $s2 = array();$/;"	v
s3	lib_crypt.php	/^		$this->s3 	= $this->init_arr_s3;$/;"	v
s3	lib_crypt.php	/^		$this->s3 	= array();$/;"	v
s3	lib_crypt.php	/^	var $s3 = array();$/;"	v
s4	lib_crypt.php	/^		$this->s4 	= $this->init_arr_s4;$/;"	v
s4	lib_crypt.php	/^		$this->s4 	= array();$/;"	v
s4	lib_crypt.php	/^	var $s4 = array();$/;"	v
salt	lib_crypt.php	/^		$this->salt = sha1('#num::'.md5(''.time()).'->'.'Date:'.date('Y-m-d H:i:s O')).'@'.md5('This is the RANDOM salt generator which must be used ! @$#&(#&)(*_*$^$*$%*$%*$^^^%&*$^($^%**!@#@^%#:"{}<>:?"');$/;"	v
salt	lib_crypt.php	/^	var $salt;			\/\/ @var	string :: Secret value added to randomize output. Change this value to add more randomness to your encryption$/;"	v
secret	lib_crypt.php	/^		$secret = $this->unixworld_key;$/;"	v
section	nasmhello.s	/^section .data$/;"	l
section	nasmhello.s	/^section .text$/;"	l
setKey	lib_crypt.php	/^	function setKey($key) {$/;"	f
string	lib_crypt.php	/^		$string = base64_decode($string);$/;"	v
string	lib_crypt.php	/^		$string = substr($string, $this->hash_length, (strlen($string) - $this->hash_length));$/;"	v
sysenter_ret	sysenter.s	/^sysenter_ret:$/;"	l
tmp_iv	lib_crypt.php	/^		$tmp_iv = substr($string, 0, $this->hash_length);$/;"	v
unixworld_key	lib_crypt.php	/^		$this->unixworld_key = $key;$/;"	v
unixworld_key	lib_crypt.php	/^	var $unixworld_key = '';$/;"	v
~B	hello.cc	/^	~B() { cout << derp << endl << noez << endl; }$/;"	f	struct:B	access:public	signature:()
~X	hello.cc	/^	~X() {$/;"	f	class:X	access:public	signature:()
